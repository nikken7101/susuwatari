/**
 * Audio stream custom element.
 * Provides generic GUI for any PCM audio stream.
 * It does not try to tackle with audio tasks, it is only a way to represent
 * the most generic API of any audio streams, like piping, starting, stopping.
 * Also it provides simple event helpers.
 *
 * @module  audio-element
 */


var AudioElementProto = Object.create(HTMLElement.prototype);


/**
 * Instance routines.
 */
AudioElementProto.createdCallback = function () {
	var self = this;

	//init inputs/outputs sets
	this.outputs = new Set();
	this.inputs = new Set();

	//init connection on load event
	//this will ensure all custom elements in DOM are parsed, registered and loaded
	//otherwise it may try to connect to nonexistent streams etc.
	//DOMContentLoaded does not guarantee that custom elements are loaded.
	if (document.readyState !== 'complete') {
		window.addEventListener("load", function () {
			self.connect(self.getAttribute('connect'));
		});
	} else {
		self.connect(self.getAttribute('connect'));
	}
};


/**
 * Watch for change of "connect" attribute, reconnect nodes.
 */
AudioElementProto.attributeChangedCallback = function ( name, previousValue, value ) {
	//reconnect
	if (name === 'connect') {
		this.disconnect(previousValue);
		this.connect(value);
	}
};


/**
 * Connect to other audio elements.
 *
 * @param {String|Element|Array} target Target to connect
 *
 * @return {AudioElementProto} this
 */
AudioElementProto.connect = function (target) {
	if (!target) return this;

	if (!this.stream) {
		throw Error('Element stream is undefined');
	}

	if (typeof target === 'string') {
		return this.connect(document.querySelectorAll(target));
	}

	if (target.length !== undefined) {
		for (var i = 0, l = target.length; i < l; i++) {
			this.connect(target[i]);
		}
		return this;
	}

	if (!(target instanceof AudioElement)) throw Error('Target is not an audio element');
	if (!target.stream) throw Error('Target stream is undefined');

	//ignore existing connection
	if (this.outputs.has(target)) return this;

	//ignore new connection if bad number of inputs
	if (this.outputs.size >= this.numberOfOutputs) throw Error('Max outputs number is ' + this.numberOfOutputs);
	if (target.inputs.size >= target.numberOfInputs) throw Error('Max inputs number is ' + target.numberOfInputs);

	//save references
	this.outputs.add(target);
	target.inputs.add(this);

	//pipe stream
	this.stream.pipe(target.stream);

	this.emit('connect', target);

	return this;
};


/**
 * Disconnect from previously connected elements
 *
 * @param {String|Element|List|Stream}? target Targets to disconnect
 */
AudioElementProto.disconnect = function (target) {
	if (!this.stream) {
		throw Error('Element stream is undefined');
	}

	//if no target passed - disconnect all
	if (!target) {
		this.outputs.forEach(function (target) {
			this.disconnect(target);
		});
		return this;
	}

	//sort out lists
	if (typeof target === 'string') {
		return this.disconnect(document.querySelectorAll(target));
	}

	if (target.length !== undefined) {
		for (var i = 0, l = target.length; i < l; i++) {
			this.disconnect(target[i]);
		}
		return this;
	}

	//check whether target is okay
	if (!(target instanceof AudioElement)) throw Error('Target is not an audio element');
	if (!target.stream) throw Error('Target stream is undefined');

	//ignore nonexisting connection
	if (!this.outputs.has(target)) return this;

	//delete references
	this.outputs.delete(target);
	target.inputs.delete(this);

	//unpipe stream
	this.stream.unpipe(target.stream);

	this.emit('disconnect', target);

	return this;
};


/**
 * Simple event helpers.
 */
AudioElementProto.emit = function (name, data) {
	this.dispatchEvent(new CustomEvent(name, { detail: data }));
};
AudioElementProto.on = AudioElementProto.addEventListener;
AudioElementProto.off = AudioElementProto.removeEventListener;


/**
 * Limitations on number of inputs/outputs.
 * By default it does not set limitations,
 * but it is better to redefine this to accord to the logic of the stream.
 */
AudioElementProto.numberOfInputs = Infinity;
AudioElementProto.numberOfOutputs = Infinity;


/**
 * Meta info.
 * Can be used by side applications.
 * Totally optional.
 */
AudioElementProto.thumbnail = 'â˜¯';
AudioElementProto.label = 'Magic';
AudioElementProto.description = 'Just try this and you will see';


/** Register custom element */
var AudioElement = document.registerElement('audio-element', {
	prototype: AudioElementProto
});


module.exports = AudioElement;